
package aem2521;

/**
 * @author Sotiria Antaranian
 */

public class Client 
{
    int core1,core2,core7,core11; 
    float totalOffer;

    /**
     * Ο κατασκευαστής αρχικοποιεί με μηδέν τους μετρητές για τα visual machines με 1,2,7 και 11 πυρήνες που θα χρησιμοποιηθούν για πελάτη και υπολογίζει τη συνολική προσφορά του πελάτη.  
     * @param cores απαιτήσεις σε πυρήνες του πελάτη
     * @param singleOffer προσφορά τιμής ανά πυρήνα
     */
    public Client(int cores,float singleOffer) 
    {
        core1=0;
        core2=0;
        core7=0;
        core11=0;
        totalOffer=cores*singleOffer;
    }
    
    int getCore1 (){return core1;}
    int getCore2 (){return core2;}
    int getCore7 (){return core7;}
    int getCore11 (){return core11;}
    float getTotalOffer (){return totalOffer;}
    
    /**
     * συγκρίνει δυο ακέραιους αριθμούς και επιστρέφει το μικρότερο
     * @param a
     * @param b
     * @return το μικρότερο
     */
    int min (int a,int b)
    {
        return (a < b)? a : b;
    }
    
    /**
     * Η πρώτη λειτουργία λύνεται όπως το πρόβλημα της ανταλλαγής ακριβούς αντίτιμου, όπου το αντίτιμο είναι οι απαιτήσεις σε πυρήνες και τα διαθέσιμα νομίσματα είναι τα visual machines με 1,2,7 και 11 πυρήνες.
     * Σκοπός είναι να βρεθεί το μικρότερο πλήθος visual machines όπου το άθροισμα των πυρήνων τους να δίνουν όσους πυρήνες ζητά ο πελάτης.
     * Σύμφωνα με το πρόβλημα της ανταλλαγής ακριβούς αντίτιμου, αρχικά θεωρούμε ότι διαθέσιμο είναι μόνο το πρώτο νόμισμα.
     *  Με την εισαγωγή του i-στου κέρματος στο υποσύνολο των διαθέσιμων νομισμάτων προκύπτουν δυο περιπτώσεις: είτε το νόμισμα αυτό θα είναι μεγαλύτερο από το απαιτούμενο αντίτιμο, 
     * οπότε η βέλτιστη λύση είναι ίδια με την περίπτωση των i-1 διαθέσιμων νομισμάτων, είτε δεν είναι μεγαλύτερο,
     * οπότε θα χρησιμοποιηθεί αν C[i-1][j] > 1+C[i][j-VMs[i-1]] , αλλιώς η βέλτιστη λύση είναι πάλι ίδια με την περίπτωση των i-1 διαθέσιμων νομισμάτων.
     * Η πολυπλοκότητα είναι Ο(n*m) όπου n ο αριθμός των διαφορετικών σε πλήθος πυρήνων διαθέσιμων visual machines και m ο αριθμός των πυρήνων που απαιτούνται και προκύπτει από τα εμφολευμένα δύο for.
     * //
     * Για την εύρεση του πόσα visual machines από το καθένα που είναι διαθέσιμα (με 1,2,7 και 11 πυρήνες) χρησιμοποιούνται, ξεκινώντας από το τελευταίο κελί της πιο δεξιά στήλης του πίνακα που προέκυψε από την εκτέλεση του παραπάνω αλγορίθμου, 
     * συγκρίνουμε κάθε κελί στη γραμμή k με το κελί πάνω του και αν είναι διαφορετικό τότε το αντίστοιχο k-στό (στο πίνακα VMs που δέχεται η συνάρτηση) διαθέσιμο visual machine χρησιμοποιείται.
     * Σε αυτή την περίπτωση μετακινούμαστε προς τα αριστερά στο πίνακα,
     * στο κελί που βρίσκεται στη στήλη για τους εναπομείναντες απαιτούμενους πυρήνες χωρίς τους πυρήνες που προσφέφει το visual machine που διαπιστώθηκε ότι χρησιμοποιείται,
     * στην ακριβώς ίδια με πριν γραμμή(επειδή μπορεί να ξαναχρησιμοποιείται visual machine με ίδιο αριθμό πυρήνων).
     * Μετά συγκρίνουμε το περιεχόμενο του κελιού με το από πάνω του κ.ο.κ.
     * Σε κάθε περίπτωση, αν τα κελιά που συγκρίνουμε είναι ίδια, πάμε στην ακριβώς από πάνω γραμμή (στην ίδια στήλη) και συγκρίνουμε το κελί σε αυτή τη γραμμή με το από πάνω του κ.ο.κ.
     * Η πολυπλοκότητα είναι Ο(n+m).
     * Η συνολική πολυπλοκότητα είναι Ο(n*m+n+m).
     * 
     * @param VMs πίνακας με το πλήθος των πυρήνων που έχει το καθένα από τα διαθέσιμα visual machines
     * @param cores οι απαιτήσεις σε πυρήνες
     */
    void  calculateVM (int []VMs,int cores)
    {
        int[][] C=new int[VMs.length+1][cores+1];
	for(int i=0;i<=VMs.length;i++) 
            C[i][0]=0;
	for(int i=1;i<=cores;i++)
            C[0][i]=10000000;
        for(int i=1;i<=VMs.length;i++) //Ο(VMs.length)
        {
            for(int j=1;j<=cores;j++) //Ο(cores)
            {
                if(VMs[i-1]<=j) //μπορεί να χρησιμοποιηθεί το visual machine με πυρήνες ίσους με τον ακέραιο στη θέση i-1
                    C[i][j]=min(C[i-1][j],1+C[i][j-VMs[i-1]]); //min επειδή ψάχνουμε το ελάχιστο δυνατό αριθμό visual machines ανά πελάτη
                else //δεν μπορεί να χρησιμοποιηθεί επειδή οι πυρήνες του είναι πιο πολλοί από αυτούς που απαιτούνται
                    C[i][j]=C[i-1][j];
            }
        }
        
        int k=VMs.length;
        int j=cores;
        while(j>=0)
        {
            if(C[k][j]!=C[k-1][j])
            {
                if(k==1)
                    core1++;
                else if(k==2)
                    core2++;
                else if(k==3)
                    core7++;
                else 
                    core11++;
                
                j=j-VMs[k-1];    
            }
            else
                k--;
            if(k==0)//αν όλα τα στοιχεία μιας στήλης είναι ίδια, πάει στο τελευταίο στοιχείο της αριστερής του στήλης
            {
                k=VMs.length;
                j--;
            }
        }
    }
    
}
