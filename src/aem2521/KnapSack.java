
package vmassigning;

import java.util.ArrayList;
import java.util.List;

/**
 * @author Sotiria Antaranian
 */

public class KnapSack 
{
    List<Integer> accepted; //λίστα με τους πελάτες που δέχεται
    
    /**
     * συγκρίνει δυο πραγματικούς αριθμούς και επιστρέφει το μεγαλύτερο
     * @param a
     * @param b
     * @return το μεγαλύτερο
     */
    
    float max(float a, float b) 
    { 
        return (a > b)? a : b; 
    }
    
    /**
     * Η δεύτερη λειτουργία λύνεται όπως το πρόβλημα του σάκου, δυναμικά, όπου η χωρητικότητα του σάκου είναι οι διαθέσιμοι πυρήνες σε όλους τους servers,
     * τα βάρη των στοιχείων είναι οι απαιτήσεις σε πυρήνες του κάθε πελάτη,
     * η αξία κάθε στοιχείου είναι το συνολικό ποσό που θα πληρώσει ο κάθε πελάτης σύμφωνα με την προσφορά του ανά πυρήνα και 
     *  το πλήθος των στοιχείων είναι το πλήθος των πελατών.
     * Σκοπός είναι να βρεθεί το πολυτιμότερο υποσύνολο των στοιχείων που χωράνε στο σάκο.
     * Για κάθε στοιχείο θα ισχύουν δυο περιπτώσεις: είτε δεν θα χωράει (wt[i-1]>w), οπότε η βέλτιστη λύση θα είναι ίδια με την περίπτωση για i-1 στοιχεία, 
     * είτε χωράει αλλά θα μπει αν val[i-1]+V[i-1][w-wt[i-1]] > V[i-1][w] , αλλιώς δεν θα μπει και η βέλτιστη λύση θα είναι πάλι η ίδια με την περίπτωση για i-1 στοιχεία.
     * Η πολυπλοκότητα, χωρική και χρονική, του προβλήματος του σάκου είναι Θ(n*W) όπου n το πλήθος των στοιχείων και W η χωριτηκότητα του σάκου και προκύπτει από τα εμφολευμένα δύο for.
     * 
     * Για την εύρεση των πελατών που γίνονται δεκτοί, ξεκινώντας από το τελευταίο δεξιά κελί του πίνακα που προέκυψε από την εκτέλεση του αλγορίθμου knap sack,
     * συγκρίνουμε κάθε κελί με το κελί πάνω του και αν είναι διαφορετικό τότε ο πελάτης που πρέπει να πληρώσει το ποσό του κελιού γίνεται δεκτός.
     * Σε αυτή την περίπτωση μετακινούμαστε προς τα αριστερά στο πίνακα, στο κελί που βρίσκεται στη στήλη για τους διαθέσιμους πυρήνες χωρίς τους πυρήνες που ζήτησε ο πελάτης που έγινε δεκτός,στην ακριβώς από πάνω γραμμή.
     * Μετά συγκρίνουμε το περιεχόμενο του κελιού με το από πάνω του κ.ο.κ.
     * Σε κάθε περίπτωση, αν τα κελιά που συγκρίνουμε είναι ίδια, πάμε στην ακριβώς από πάνω γραμμή (στην ίδια στήλη) και συγκρίνουμε το κελί σε αυτή τη γραμμή με το από πάνω του κ.ο.κ.
     * Για την εύρεση των αποδεκτών πελατών η πολυπλοκότητα είναι Ο(n+W) στη χειρότερη περίπτωση.
     * Η συνολική πολυπλοκότητα είναι Ο(n*W+n+W).
     * 
     * @param W η χωρητικότητα του σάκου
     * @param wt πίνακας με τα βάρη των n στοιχείων
     * @param val πίνακας με την αξία του κάθε στοιχείου
     * @param n το πλήθος των στοιχείων 
     * @return συνολικό ποσό πληρωμής από όλους τους πελάτες
     */
    float knapSack(int W,int wt[],float val[],int n)
    {
        accepted=new ArrayList<>();
        float [][]V=new float[n+1][W+1];
        for(int i=0;i<=n;i++) //πολυπλοκότητα Ο(n)
        {
            for(int w=0;w<=W;w++) //πολυπλοκότητα O(W)
            {
                if(i==0 || w==0)
                    V[i][w]=0;
                else if(wt[i-1]-w<=0) //χωράει
                    V[i][w]=max(val[i-1]+V[i-1][w-wt[i-1]],V[i-1][w]);
                else  //δεν χωράει
                    V[i][w]=V[i-1][w];
            }
        }
        int k=n;
        int j=W;
        while(j!=0)
        {
            if(V[k][j]!=V[k-1][j]) //δεκτός πελάτης
            {
                accepted.add(k);
                j=j-wt[k-1]; //αλλαγή στήλης
            }
            k--; //αλλαγή γραμμής
            if(k==0)//αν όλα τα στοιχεία μιας στήλης είναι ίδια, πάει στο τελευταίο στοιχείο της αριστερής του στήλης
            {
                k=n;
                j--;
            }
        }
        
        return V[n][W];
    }
}
